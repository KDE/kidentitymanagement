diff --git a/kpimidentities/src/signature.cpp b/kpimidentities/src/signature.cpp
index 1d81e4c..258f138 100644
--- a/kpimidentities/src/signature.cpp
+++ b/kpimidentities/src/signature.cpp
@@ -40,11 +40,24 @@
 
 using namespace KIdentityManagement;
 
-class SignaturePrivate
+QDataStream &operator<< ( QDataStream &stream, const Signature::Private::EmbeddedImagePtr &img )
 {
-  public:
-    SignaturePrivate()
-      :enabled( false )
+  return stream << img->image << img->name;
+}
+
+QDataStream &operator>> ( QDataStream &stream, Signature::Private::EmbeddedImagePtr &img )
+{
+  return stream >> img->image >> img->name;
+}
+
+class KIdentityManagement::Signature::Private
+{
+public:
+    Private(Signature *qq)
+      : enabled( false ),
+        mType(Inlined),
+        mInlinedHtml(false),
+        q(qq)
     {
     }
     struct EmbeddedImage
@@ -61,67 +74,48 @@ class SignaturePrivate
     /// The directory where the images will be saved to.
     QString saveLocation;
     bool enabled;
-};
+    QString mUrl;
+    QString mText;
+    Signature::Type    mType;
+    bool mInlinedHtml;
 
-QDataStream &operator<< ( QDataStream &stream, const SignaturePrivate::EmbeddedImagePtr &img )
-{
-  return stream << img->image << img->name;
-}
-
-QDataStream &operator>> ( QDataStream &stream, SignaturePrivate::EmbeddedImagePtr &img )
-{
-  return stream >> img->image >> img->name;
-}
-
-// TODO: KDE5: BIC: Add a real d-pointer.
-// This QHash is just a workaround around BIC issues, for more info see
-// http://techbase.kde.org/Policies/Binary_Compatibility_Issues_With_C++
-typedef QHash<const Signature*,SignaturePrivate*> SigPrivateHash;
-Q_GLOBAL_STATIC( SigPrivateHash, d_func )
-
-static SignaturePrivate* d( const Signature *sig )
-{
-  SignaturePrivate *ret = d_func()->value( sig, 0 );
-  if ( !ret ) {
-    ret = new SignaturePrivate;
-    d_func()->insert( sig, ret );
-  }
-  return ret;
-}
+    Signature *q;
+};
 
-static void delete_d( const Signature* sig )
+Signature::Signature()
+  : d( new Private( this ) )
 {
-  SignaturePrivate *ret = d_func()->value( sig, 0 );
-  delete ret;
-  d_func()->remove( sig );
+    d->mType =  Disabled;
+    d->mInlinedHtml = false;
 }
 
-Signature::Signature()
-  : mType( Disabled ),
-    mInlinedHtml( false )
-{}
-
 Signature::Signature( const QString &text )
   : mText( text ),
     mType( Inlined ),
-    mInlinedHtml( false )
-{}
+    mInlinedHtml( false ),
+    d( new Private( this ) )
+{
+    d->mType =  Inlined;
+    d->mInlinedHtml = false;
+}
 
 Signature::Signature( const QString &url, bool isExecutable )
-  : mUrl( url ),
-    mType( isExecutable ? FromCommand : FromFile ),
-    mInlinedHtml( false )
-{}
+  : d( new Private( this ) )
+{
+    d->mUrl = url;
+    d->mType = ( isExecutable ? FromCommand : FromFile );
+    d->mInlinedHtml = false;
+}
 
 void Signature::assignFrom ( const KIdentityManagement::Signature &that )
 {
-  mUrl = that.mUrl;
-  mInlinedHtml = that.mInlinedHtml;
-  mText = that.mText;
-  mType = that.mType;
-  d( this )->enabled = d( &that )->enabled;
-  d( this )->saveLocation = d( &that )->saveLocation;
-  d( this )->embeddedImages = d( &that )->embeddedImages;
+  d->mUrl = that.url();
+  d->mInlinedHtml = that.isInlinedHtml();
+  d->mText = that.text();
+  d->mType = that.type();
+  d->enabled = that.isEnabledSignature();
+  d->saveLocation = that.imageLocation();
+  d->embeddedImages = d( &that )->embeddedImages;
 }
 
 Signature::Signature ( const Signature &that )
@@ -141,12 +135,12 @@ Signature& Signature::operator= ( const KIdentityManagement::Signature & that )
 
 Signature::~Signature()
 {
-  delete_d( this );
+    delete d;
 }
 
 QString Signature::rawText( bool *ok ) const
 {
-  switch ( mType ) {
+  switch ( d->mType ) {
   case Disabled:
     if ( ok ) {
       *ok = true;
@@ -168,10 +162,10 @@ QString Signature::rawText( bool *ok ) const
 
 QString Signature::textFromCommand( bool *ok ) const
 {
-  assert( mType == FromCommand );
+  assert( d->mType == FromCommand );
 
   // handle pathological cases:
-  if ( mUrl.isEmpty() ) {
+  if ( d->mUrl.isEmpty() ) {
     if ( ok ) {
       *ok = true;
     }
@@ -181,7 +175,7 @@ QString Signature::textFromCommand( bool *ok ) const
   // create a shell process:
   KProcess proc;
   proc.setOutputChannelMode( KProcess::SeparateChannels );
-  proc.setShellCommand( mUrl );
+  proc.setShellCommand( d->mUrl );
   int rc = proc.execute();
 
   // handle errors, if any:
@@ -190,7 +184,7 @@ QString Signature::textFromCommand( bool *ok ) const
       *ok = false;
     }
     const QString wmsg = i18n( "<qt>Failed to execute signature script<p><b>%1</b>:</p>"
-                         "<p>%2</p></qt>", mUrl, QLatin1String( proc.readAllStandardError() ) );
+                         "<p>%2</p></qt>", d->mUrl, QLatin1String( proc.readAllStandardError() ) );
     KMessageBox::error( 0, wmsg );
     return QString();
   }
@@ -209,12 +203,12 @@ QString Signature::textFromCommand( bool *ok ) const
 
 QString Signature::textFromFile( bool *ok ) const
 {
-  assert( mType == FromFile );
+  assert( d->mType == FromFile );
 
   // TODO: Use KIO::NetAccess to download non-local files!
-  if ( !KUrl( mUrl ).isLocalFile() &&
-       !( QFileInfo( mUrl ).isRelative() &&
-          QFileInfo( mUrl ).exists() ) ) {
+  if ( !KUrl( d->mUrl ).isLocalFile() &&
+       !( QFileInfo( d->mUrl ).isRelative() &&
+          QFileInfo( d->mUrl ).exists() ) ) {
     kDebug( 5325 ) << "Signature::textFromFile:"
     << "non-local URLs are unsupported";
     if ( ok ) {
@@ -228,7 +222,7 @@ QString Signature::textFromFile( bool *ok ) const
   }
 
   // TODO: hmm, should we allow other encodings, too?
-  const QByteArray ba = KPIMUtils::kFileToByteArray( mUrl, false );
+  const QByteArray ba = KPIMUtils::kFileToByteArray( d->mUrl, false );
   return QString::fromLocal8Bit( ba.data(), ba.size() );
 }
 
@@ -243,7 +237,7 @@ QString Signature::withSeparator( bool *ok ) const
     return signature; // don't add a separator in this case
   }
 
-  const bool htmlSig = ( isInlinedHtml() && mType == Inlined );
+  const bool htmlSig = ( isInlinedHtml() && d->mType == Inlined );
   QString newline = htmlSig ? QLatin1String("<br>") : QLatin1String("\n");
   if ( htmlSig && signature.startsWith( QLatin1String( "<p" ) ) ) {
     newline.clear();
@@ -261,18 +255,18 @@ QString Signature::withSeparator( bool *ok ) const
 
 void Signature::setUrl( const QString &url, bool isExecutable )
 {
-  mUrl = url;
-  mType = isExecutable ? FromCommand : FromFile;
+  d->mUrl = url;
+  d->mType = isExecutable ? FromCommand : FromFile;
 }
 
 void Signature::setInlinedHtml( bool isHtml )
 {
-  mInlinedHtml = isHtml;
+  d->mInlinedHtml = isHtml;
 }
 
 bool Signature::isInlinedHtml() const
 {
-  return mInlinedHtml;
+  return d->mInlinedHtml;
 }
 
 // config keys and values:
@@ -306,23 +300,23 @@ void Signature::cleanupImages() const
 {
   // Remove any images from the internal structure that are no longer there
   if ( isInlinedHtml() ) {
-    foreach ( const SignaturePrivate::EmbeddedImagePtr &imageInList, d( this )->embeddedImages ) {
+    foreach ( const Signature::Private::EmbeddedImagePtr &imageInList, d->embeddedImages ) {
       bool found = false;
-      foreach ( const QString &imageInHtml, findImageNames( mText ) ) {
+      foreach ( const QString &imageInHtml, findImageNames( d->mText ) ) {
         if ( imageInHtml == imageInList->name ) {
           found = true;
           break;
         }
       }
       if ( !found ) {
-        d( this )->embeddedImages.removeAll( imageInList );
+        d->embeddedImages.removeAll( imageInList );
       }
     }
   }
 
   // Delete all the old image files
-  if ( !d( this )->saveLocation.isEmpty() ) {
-    QDir dir( d( this )->saveLocation );
+  if ( !d->saveLocation.isEmpty() ) {
+    QDir dir( d->saveLocation );
     foreach ( const QString &fileName, dir.entryList( QDir::Files | QDir::NoDotAndDotDot | QDir::NoSymLinks ) ) {
       if ( fileName.toLower().endsWith( QLatin1String( ".png" ) ) ) {
         qDebug() << "Deleting old image" << dir.path() + fileName;
@@ -334,9 +328,9 @@ void Signature::cleanupImages() const
 
 void Signature::saveImages() const
 {
-  if ( isInlinedHtml() && !d( this )->saveLocation.isEmpty() ) {
-    foreach ( const SignaturePrivate::EmbeddedImagePtr &image, d( this )->embeddedImages ) {
-      QString location = d( this )->saveLocation + QLatin1Char('/') + image->name;
+  if ( isInlinedHtml() && !d->saveLocation.isEmpty() ) {
+    foreach ( const Signature::Private::EmbeddedImagePtr &image, d->embeddedImages ) {
+      QString location = d->saveLocation + QLatin1Char('/') + image->name;
       if ( !image->image.save( location, "PNG" ) ) {
         qWarning() << "Failed to save image" << location;
       }
@@ -348,25 +342,25 @@ void Signature::readConfig( const KConfigGroup &config )
 {
   QString sigType = config.readEntry( sigTypeKey );
   if ( sigType == QLatin1String(sigTypeInlineValue) ) {
-    mType = Inlined;
-    mInlinedHtml = config.readEntry( sigTypeInlinedHtmlKey, false );
+    d->mType = Inlined;
+    d->mInlinedHtml = config.readEntry( sigTypeInlinedHtmlKey, false );
   } else if ( sigType == QLatin1String(sigTypeFileValue) ) {
-    mType = FromFile;
-    mUrl = config.readPathEntry( sigFileKey, QString() );
+    d->mType = FromFile;
+    d->mUrl = config.readPathEntry( sigFileKey, QString() );
   } else if ( sigType == QLatin1String(sigTypeCommandValue) ) {
-    mType = FromCommand;
-    mUrl = config.readPathEntry( sigCommandKey, QString() );
+    d->mType = FromCommand;
+    d->mUrl = config.readPathEntry( sigCommandKey, QString() );
   } else if ( sigType == QLatin1String(sigTypeDisabledValue) ) {
-    d( this )->enabled = false;
+    d->enabled = false;
   }
-  if ( mType != Disabled ) {
-    d( this )->enabled = config.readEntry( sigEnabled, true );
+  if ( d->mType != Disabled ) {
+    d->enabled = config.readEntry( sigEnabled, true );
   }
 
-  mText = config.readEntry( sigTextKey );
-  d( this )->saveLocation = config.readEntry( sigImageLocation );
+  d->mText = config.readEntry( sigTextKey );
+  d->saveLocation = config.readEntry( sigImageLocation );
 
-  if ( isInlinedHtml() && !d( this )->saveLocation.isEmpty() ) {
+  if ( isInlinedHtml() && !d->saveLocation.isEmpty() ) {
     QDir dir( d( this )->saveLocation );
     foreach ( const QString &fileName, dir.entryList( QDir::Files | QDir::NoDotAndDotDot | QDir::NoSymLinks ) ) {
       if ( fileName.toLower().endsWith( QLatin1String( ".png" ) ) ) {
@@ -384,25 +378,25 @@ void Signature::readConfig( const KConfigGroup &config )
 
 void Signature::writeConfig( KConfigGroup &config ) const
 {
-  switch ( mType ) {
+  switch ( d->mType ) {
     case Inlined:
       config.writeEntry( sigTypeKey, sigTypeInlineValue );
-      config.writeEntry( sigTypeInlinedHtmlKey, mInlinedHtml );
+      config.writeEntry( sigTypeInlinedHtmlKey, d->mInlinedHtml );
       break;
     case FromFile:
       config.writeEntry( sigTypeKey, sigTypeFileValue );
-      config.writePathEntry( sigFileKey, mUrl );
+      config.writePathEntry( sigFileKey, d->mUrl );
       break;
     case FromCommand:
       config.writeEntry( sigTypeKey, sigTypeCommandValue );
-      config.writePathEntry( sigCommandKey, mUrl );
+      config.writePathEntry( sigCommandKey, d->mUrl );
       break;
     default:
       break;
   }
-  config.writeEntry( sigTextKey, mText );
-  config.writeEntry( sigImageLocation, d( this )->saveLocation );
-  config.writeEntry( sigEnabled, d( this )->enabled );
+  config.writeEntry( sigTextKey, d->mText );
+  config.writeEntry( sigImageLocation, d->saveLocation );
+  config.writeEntry( sigEnabled, d->enabled );
 
   cleanupImages();
   saveImages();
@@ -547,7 +541,7 @@ void Signature::insertSignatureText(Placement placement, AddedText addedText, KP
 
   // We added the text of the signature above, now it is time to add the images as well.
   if ( isInlinedHtml() ) {
-    foreach ( const SignaturePrivate::EmbeddedImagePtr &image, d( this )->embeddedImages ) {
+    foreach ( const Signature::Private::EmbeddedImagePtr &image, d->embeddedImages ) {
       textEdit->loadImage( image->image, image->name, image->name );
     }
   }
@@ -565,7 +559,7 @@ void Signature::insertPlainSignatureIntoTextEdit( const QString &signature, KRic
 QDataStream &KIdentityManagement::operator<<
 ( QDataStream &stream, const KIdentityManagement::Signature &sig )
 {
-  return stream << static_cast<quint8>( sig.mType ) << sig.mUrl << sig.mText
+  return stream << static_cast<quint8>( sig.type() ) << sig.url() << sig.text()
                 << d( &sig )->saveLocation << d( &sig )->embeddedImages << d( &sig )->enabled;
 }
 
@@ -573,36 +567,36 @@ QDataStream &KIdentityManagement::operator>>
 ( QDataStream &stream, KIdentityManagement::Signature &sig )
 {
   quint8 s;
-  stream >> s  >> sig.mUrl >> sig.mText >> d( &sig )->saveLocation >> d( &sig )->embeddedImages >>d( &sig )->enabled;
+  stream >> s  >> sig.d->mUrl >> sig.mText >> d( &sig )->saveLocation >> d( &sig )->embeddedImages >>d( &sig )->enabled;
   sig.mType = static_cast<Signature::Type>( s );
   return stream;
 }
 
 bool Signature::operator== ( const Signature &other ) const
 {
-  if ( mType != other.mType ) {
+  if ( d->mType != other.type() ) {
     return false;
   }
 
-  if ( d( this )->enabled != d( &other )->enabled ) {
+  if ( d->enabled != d( &other )->enabled ) {
     return false;
   }
 
-  if ( mType == Inlined && mInlinedHtml ) {
-    if ( d( this )->saveLocation != d( &other )->saveLocation ) {
+  if ( d->mType == Inlined && d->mInlinedHtml ) {
+    if ( d->saveLocation != d->imageLocation() ) {
       return false;
     }
-    if ( d( this )->embeddedImages != d( &other )->embeddedImages ) {
+    if ( d->embeddedImages != d( &other )->embeddedImages ) {
       return false;
     }
   }
 
   switch ( mType ) {
   case Inlined:
-    return mText == other.mText;
+    return mText == other.text();
   case FromFile:
   case FromCommand:
-    return mUrl == other.mUrl;
+    return mUrl == other.url();
   default:
   case Disabled:
     return true;
@@ -625,55 +619,64 @@ QString Signature::toPlainText() const
 
 void Signature::addImage ( const QImage& imageData, const QString& imageName )
 {
-  Q_ASSERT( !( d( this )->saveLocation.isEmpty() ) );
-  SignaturePrivate::EmbeddedImagePtr image( new SignaturePrivate::EmbeddedImage() );
+  Q_ASSERT( !( d->saveLocation.isEmpty() ) );
+  Signature::Private::EmbeddedImagePtr image( new Signature::Private::EmbeddedImage() );
   image->image = imageData;
   image->name = imageName;
-  d( this )->embeddedImages.append( image );
+  d->embeddedImages.append( image );
 }
 
 void Signature::setImageLocation ( const QString& path )
 {
-  d( this )->saveLocation = path;
+  d->saveLocation = path;
 }
 
 // --------------- Getters -----------------------//
 
 QString Signature::text() const
 {
-  return mText;
+  return d->mText;
 }
 
 QString Signature::url() const
 {
-  return mUrl;
+  return d->mUrl;
 }
 
 Signature::Type Signature::type() const
 {
-  return mType;
+  return d->mType;
 }
 
+QString Signature::imageLocation() const
+{
+    return d->saveLocation;
+}
 // --------------- Setters -----------------------//
 
 void Signature::setText( const QString &text )
 {
-  mText = text;
-  mType = Inlined;
+  d->mText = text;
+  d->mType = Inlined;
 }
 
 void Signature::setType( Type type )
 {
-  mType = type;
+  d->mType = type;
 }
 
 
 void Signature::setEnabledSignature(bool enabled)
 {
-  d( this )->enabled = enabled;
+  d->enabled = enabled;
 }
 
 bool Signature::isEnabledSignature() const
 {
-  return d( this )->enabled;
+  return d->enabled;
+}
+
+QList<Signature::Private::EmbeddedImagePtr> Signature::embeddedImage() const
+{
+  return d->embeddedImages;
 }
diff --git a/kpimidentities/src/signature.h b/kpimidentities/src/signature.h
index 116d17c..b8de09a 100644
--- a/kpimidentities/src/signature.h
+++ b/kpimidentities/src/signature.h
@@ -280,7 +280,9 @@ namespace KIdentityManagement
                                                                    Placement placement = End,
                                                                    bool isHtml = false );
 
-    protected:
+      QString imageLocation() const;
+      QList<Signature::Private::EmbeddedImagePtr> embeddedImage() const;
+  protected:
 
       // TODO: KDE5: BIC: Move all to private class
       void writeConfig( KConfigGroup &config ) const;
@@ -310,12 +312,10 @@ namespace KIdentityManagement
       QString textFromFile( bool *ok ) const;
       QString textFromCommand( bool *ok ) const;
 
-      // TODO: KDE5: BIC: Add a d-pointer!!!
-      //       There is already a pseude private class in the .cpp, using a hash.
-      QString mUrl;
-      QString mText;
-      Type    mType;
-      bool mInlinedHtml;
+      //@cond PRIVATE
+      class Private;
+      Private *d;
+      //@endcond
   };
 
   Q_DECLARE_OPERATORS_FOR_FLAGS( Signature::AddedText )
